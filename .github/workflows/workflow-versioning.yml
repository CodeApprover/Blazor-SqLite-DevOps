---
name: Versioning Workflow

on:
  repository_dispatch:
    types: trigger-versioning

env:
  PROJ_NAME: "Blazor-SqLite-Golf-Club"

jobs:
  version-and-tag:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    # Checking out the repository for the payload SHA
    - name: Checkout SHA repository
      uses: actions/checkout@v3.5.3
      with:
        ref: ${{ github.event.client_payload.sha }}
        fetch-depth: 0

    # Configure git user for commits in this workflow
    - name: Configure Git User
      run: |
        git config user.name "CodeApprover"
        git config user.email "pucfada@pm.me"

    # Set the branch name for the payload SHA
    - name: Set Branch and Lock File
      run: |
        # Trap error and echo failed line number and command
        trap 'echo "Error on line $LINENO: $BASH_COMMAND"; exit 1' ERR

        # Identify the branch that contains the given SHA
        branch=$(git branch -r --contains ${{ github.event.client_payload.sha }} | grep 'origin/' | sed 's#origin/##' | head -n 1 | xargs)
        echo "Detected branch: $branch"
        
        # Exit if the branch can't be identified
        if [[ -z "${branch}" ]]; then
          echo "Failed to extract branch name for SHA: ${{ github.event.client_payload.sha }}"
          exit 1 
        fi
        
        # Set the branch name 
        echo "BRANCH_NAME=${branch}" >> $GITHUB_ENV

        # Set lock file name based on branch name
        case "${branch}" in
          "code-production")
            echo "LOCK_FILE=.production.lock" >> $GITHUB_ENV
            ;;
          "code-staging"):
            echo "LOCK_FILE=.staging.lock" >> $GITHUB_ENV
            ;;
          "code-development"):
            echo "LOCK_FILE=.development.lock" >> $GITHUB_ENV
            ;;
          "main"):
            echo "LOCK_FILE=.main.lock" >> $GITHUB_ENV
            ;;
          # Exit if branch name unknown
          *):
            echo "Unknown branch: $branch. Exiting."
            exit 1
            ;;
        esac

    # Attempt to acquire branch-specific lock file
    - name: Attempt to acquire lock
      run: |
        trap 'echo "Error on line $LINENO: $BASH_COMMAND"; exit 1' ERR
        git pull origin ${{ env.BRANCH_NAME }}
        
        # Check for a pre-existing lock file in the branch (excluding current SHA)
        lock_exists=$(git log --format="%H" -n 1 --skip 1 | xargs git show --name-only --oneline | grep "${{ env.LOCK_FILE }}")
        
        # Exit if a lock file is found, meaning another job is already in progress
        if [[ ! -z "$lock_exists" ]]; then
          echo "Found active ${{ env.LOCK_FILE }}! Another job is in progress. Exiting."
          exit 1
        fi

        # Create and commit a lock file to prevent other jobs from proceeding concurrently
        echo "$(date +%s)" > "${{ env.LOCK_FILE }}"
        git add "${{ env.LOCK_FILE }}"
        git commit -m "Add lock for versioning"
        
        # Push the lock file to the repository; exit on failure
        if ! git push origin HEAD:${{ env.BRANCH_NAME }}; then
          echo "Failed to push. Exiting."
          exit 1
        fi

    # Determine the next version tag based on existing tags and the branch
    - name: Determine next version tag
      run: |
        trap 'echo "Error on line $LINENO: $BASH_COMMAND"; exit 1' ERR
        
        # Fetch all the tags from the repository
        git fetch --tags

        # Exit if no tags are found
        if [ -z "$(git tag)" ]; then
          echo "No tags found. Exiting."
          exit 1
        fi
        
        # Determine the highest version tag available
        highest_version=$(git tag | sort -V | tail -n 1)
        
        # Split this tag into major, minor, and patch versions
        major_version=$(echo $highest_version | cut -d. -f1 | tr -dc '0-9')
        minor_version=$(echo $highest_version | cut -d. -f2)
        patch_version=$(echo $highest_version | cut -d. -f3)
        
        # Extract the latest tag based on the commit date
        filtered_tags=$(git tag | grep "^$major_version\.$minor_version\.$patch_version")
        latest_tag=$(for tag in $filtered_tags; do
            echo $(git log -1 --format=%ai $tag) $tag
        done | sort | tail -n 1 | awk '{print $NF}')
        
        # Increment the tag version based on the branch and the latest tag
        major=$(echo "$latest_tag" | cut -d'.' -f1 | tr -dc '0-9')
        minor=$(echo "$latest_tag" | cut -d'.' -f2)
        patch=$(echo "$latest_tag" | cut -d'.' -f3)
        case "${{ env.BRANCH_NAME }}" in
          "code-production")
            major=$((major + 1))
            minor=0
            patch=0
            ;;
          "code-staging")
            minor=$((minor + 1))
            patch=0
            ;;
          "code-development")
            patch=$((patch + 1))
            ;;
          "main")
            ;;
          *)
            echo "Unknown branch: ${{ env.BRANCH_NAME }}. Retaining current version."
            ;;
        esac
        
        new_version="v$major.$minor.$patch"
        echo "Determined new version: $new_version"
        echo "NEW_VERSION=$new_version" >> $GITHUB_ENV

    # Tag the repository with the newly determined version
    - name: Tag the repository with new version
      run: |
        trap 'echo "Error on line $LINENO: $BASH_COMMAND"; exit 1' ERR
        
        # Tag the repository
        git tag "${{ env.NEW_VERSION }}"
        echo "Tagged the repo with: ${env.NEW_VERSION}"

    # Push the new tag to the main repository
    - name: Push new tag to repository
      run: |
        trap 'echo "Error on line $LINENO: $BASH_COMMAND"; exit 1' ERR
        
        # Push the tag
        git push origin "${{ env.NEW_VERSION }}"
        echo "Pushed the new tag to origin"

    # Remove the lock file once versioning is complete
    - name: Release the lock
      run: |
        trap 'echo "Error on line $LINENO: $BASH_COMMAND"; exit 1' ERR
        
        # Remove the lock file
        git rm "${{ env.LOCK_FILE }}"
        git commit -m "Remove lock after versioning"
        
        # Push the changes, removing the lock file
        git push origin HEAD:${{ env.BRANCH_NAME }}
        echo "Lock file released"

    # Deploy a docker image of the sha commit
    - name: Trigger Docker Deployment
      run: |
        trap 'echo "Error on line $LINENO: $BASH_COMMAND"; exit 1' ERR
        response=$(curl -s -o /dev/null -w "%{http_code}" \
                 -X POST \
                 -H "Authorization: Bearer ${{ secrets.AUTH }}" \
                 -H "Accept: application/vnd.github.v3+json" \
                 https://api.github.com/repos/${{ github.repository }}/dispatches \
                 -d '{ "event_type": "trigger-docker-deploy", "client_payload": { "sha": "${{ github.sha }}" } }')
    
        if [ "$response" -ne 200 ]; then
          echo "Failed to trigger Docker deployment. HTTP response code: $response"
          exit 1
        fi
        echo "Successfully triggered Docker deployment."
