---
######################################
# Workflow: Commit Guard

# Description:
# This workflow manages the response to failed deployments.
# It verifies the workflow's environment, extracts crucial data,
# reverts commits if necessary, possibly deletes tags and notifies the team.

# Trigger: Activated upon the completion of various specified workflows.

# Logical Flow (Steps):
# 1.  Extract branch from GitHub ref and determine environment from branch.
# 2.  Identify lock file and extract SHA.
# 3.  Checkout the repository using the SHA from the lock file.
# 4.  Validate the SHA checkout.
# 5.  Revert the commits based on the SHA.
# 6.  Push the reversion changes to the origin.
# 7.  Delete the latest tag locally (if it exists).
# 8.  Delete the latest tag remotely (if it exists).
# 9.  Set relevant team members.
# 10. Notify team about the reverted commit.
# 11. Catch all for failures reports on any failures in this workflow execution.

# Exit Codes:
# 24 - Failed to revert commit. (Reused)
# 25 - Failed to push reversion. (Reused)
# 26 - SHA checkout failure. (Reused)

# 40 - Branch name is not populated.
# 41 - Environment is not populated.
# 42 - Lock file has invalid SHA.
# 43 - Lock file not found.
# 44 - Failed to delete the tag locally.
# 45 - Failed to delete the tag remotely.
# 46 - Failed to notify teams and committer.
# 47 - Catch-all for failures

######################################

name: Commit Guard

on:
  workflow_run:

    workflows:
      - Authentication Gate
      - Cache Dependencies
      - StyleCop Linter
      - Development Tests
      - Staging Tests
      - Production Tests
      - Lockfile Checker
      - Security Scan
      - Superlinter
      - Versioning
      - Deploy Docker
      - Deploy Git
      - Success

    types:
      - completed

env:
  GITHUB_TOKEN: ${{ secrets.AUTH }}

jobs:

  handle-workflow-failure:
    name: Handle Workflow Failure
    runs-on: ubuntu-latest
    timeout-minutes: 15

    if: ${{ github.event.workflow_run.conclusion != 'success' }}
    
    steps:

    # Step 1: Extract branch from github ref and environment from branch.
    - name: Determine Deployment Context
      run: |
 
        echo "##[debug][extract] setting branch name from github.ref"
        branch=${{ github.ref }}
        branch_name=${branch#refs/heads/}
        if [[ -z "$branch_name" ]]; then
          echo "##[error][extract] Branch name is not populated."
          exit 40
        fi
        echo "##[debug][extract] Branch Name: $branch_name"

        echo "##[debug][extract] setting environment name from branch name $branch_name"
        environment=${branch_name#code-}
        if [[ -z "$environment" ]]; then
          echo "##[error][extract] Environment is not populated."
          exit 41
        fi
        echo "##[debug][extract] Environment: $environment"

        echo "BRANCH_NAME=$branch_name" >> $GITHUB_ENV
        echo "ENVIRONMENT=$environment" >> $GITHUB_ENV

    # Step 2: Identify lock file and extract SHA.
    - name: Retrieve Commit SHA from Lock File
      run: |
 
        lock_file_path=$(find . -name "${{ env.ENVIRONMENT }}.lock" | head -n 1)
        echo "##[debug][lockfile] Lock file path $lock_file_path"

        if [[ -n "$lock_file_path" ]]; then
          sha=$(cat "$lock_file_path")
          if [[ ${#sha} -eq 40 && $sha =~ ^[0-9a-fA-F]+$ ]]; then
            echo "##[debug][lockfile] Lock File SHA: $sha"
            echo "SHA=$sha" >> $GITHUB_ENV
          else
            echo "##[error][lockfile] Lock file $lock_file_path has invalid sha $sha."
            exit 42
          fi
        else:
          echo "##[error][lockfile] Lock file not found for the ${{ env.ENVIRONMENT }} environment."
          exit 43
        fi

    # Step 3: Checkout repository using SHA.
    - name: Checkout SHA Repository
      id: checkout-sha
      uses: actions/checkout@v3.6.0
      with:
        ref: ${{ github.sha }}
        fetch-depth: 0

    # Step 4: Validate SHA checkout.
    - name: Validate Checkout
      run: |
 
        if [ $? -ne 0 ]; then
            echo "##[error][checkout] SHA checkout failure ${{ github.sha }}"
            exit 26
        fi

    # Step 5: Revert the commits based on the SHA.
    - name: Revert Commit(s) Based on SHA
      run: |
 
        determine_target_sha() {
          if [[ "${{ env.SHA }}" ]]; then
            echo "${{ env.SHA }}"
          else
            echo "${{ github.event.workflow_run.head_sha }}"
          fi
        }
        TARGET_SHA=$(determine_target_sha)
        echo "##[debug][target-sha] Target SHA for Reversion: $TARGET_SHA"
    
        git config user.name "${{ github.repository_owner }}"
        git config user.email "${{ vars.EMAIL }}"
    
        if [[ "${{ env.SHA }}" ]]; then
          git revert HEAD || {
            echo "##[error][revert] Failed to revert commit from ${{ env.SHA }}."
            exit 24
          }
        else
          git revert "$TARGET_SHA^..HEAD" || {
            echo "##[error][revert] Failed to revert commit from 1 before triggreing commit."
            exit 24
          }
        fi

    # Step 6: Push the reversion changes to the origin.
    - name: Push Reversion Changes
      run: |
 
        if git push origin HEAD:${{ github.ref }}; then
          echo "##[debug][push] Pushed reversion."
        else
          echo "##[error][push] Failed to push reversion."
          exit 25
        fi

    # Step 7: Delete the latest tag (locally) if it exists.
    - name: Delete Latest Tag (Locally)
      run: |
 
        latest_tag=$(git describe --tags --abbrev=0)
        if [[ "$latest_tag" ]]; then
          git tag -d "$latest_tag" || {
            echo "##[error][tag] Failed to delete the tag locally."
            exit 44
          }
          echo "##[debug][tag] Deleted tag: $latest_tag locally."
        fi

    # Step 8: Delete the latest tag (remotely) if it exists.
    - name: Delete Latest Tag (Remotely)
      run: |
 
        latest_tag=$(git describe --tags --abbrev=0)
        if [[ "$latest_tag" ]]; then
          git push --delete origin "$latest_tag" || {
            echo "##[error][tag] Failed to delete the tag remotely."
            exit 45
          }
          echo "##[debug][tag] Deleted tag: $latest_tag remotely."
        fi

    # Step 9: Set Relevant Team members.
    - name: Notify Relevant Teams and Committer
      run: |
 
        echo "##[debug][notify] Fetching the name of the original committer of the commit."
        ORIGINAL_COMMITTER=$(git log --pretty=format:'%an' ${{ env.SHA }} | head -n 1)

        echo "##[debug][notify] Fetching the commit message of the payload commit."
        COMMIT_MESSAGE=$(git log --pretty=format:'%B' -n 1 ${{ env.SHA }})

        echo "##[debug][notify] Determining the relevant team to notify based on SHA_BRANCH."
        if [[ "${{ env.SHA_BRANCH }}" == "code-development" ]]; then
          TEAM_TO_NOTIFY="${{ secrets.STAGING_TEAM }}"
          ADDITIONAL_MESSAGE="The code-staging branch has received an update."
        elif [[ "${{ env.SHA_BRANCH }}" == "code-staging" ]]; then
          TEAM_TO_NOTIFY="${{ secrets.PRODUCTION_TEAM }}"
          ADDITIONAL_MESSAGE="The code-production branch has received an update."
        elif [[ "${{ env.SHA_BRANCH }}" == "code-production" ]] || [[ "${{ env.SHA_BRANCH }}" == "main" ]]; then
          TEAM_TO_NOTIFY=""
          ADDITIONAL_MESSAGE=""
        fi

        echo "##[debug][notify] Converting CSV list to space-separated list with "@" prefixed and remove duplicates."
        format_team_to_notify() {
          local csv="$1"
          echo "$csv" | tr ',' '\n' | sort | uniq | awk '{print "@"$0}' | tr '\n' ' '
        }
        FORMATTED_TEAM_TO_NOTIFY=$(format_team_to_notify "$TEAM_TO_NOTIFY")
        echo "##[debug][notify] TEAM TO NOTIFY: $FORMATTED_TEAM_TO_NOTIFY"
        echo "##[debug][notify] ORIGINAL COMMITTER: $ORIGINAL_COMMITTER"

        echo "##[debug][notify] Constructing notification title and body."
        ISSUE_TITLE="Commit Reverted: ${{ env.SHA }}"
                ISSUE_BODY=$(echo "Hello @$ORIGINAL_COMMITTER @${{ github.repository_owner }} $FORMATTED_TEAM_TO_NOTIFY

          Commit: ${{ env.SHA }}
          Committer: $ORIGINAL_COMMITTER
          Commit Message: $COMMIT_MESSAGE
          
          Commit has been successfully deployed to ${{ env.SHA_BRANCH }}.
          NOTE: $FORMATTED_TEAM_TO_NOTIFY: $ADDITIONAL_MESSAGE

          Thank you for your contribution @$ORIGINAL_COMMITTER")

        create_issue() {
          local title="$1"
          local body="$2"
          payload=$(jq -n \
            --arg title "$title" \
            --arg body "$body" \
            '{title: $title, body: $body}')
          CURL_CMD=$(echo "curl -X POST" \
            "-H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\"" \
            "-H \"Accept: application/vnd.github.v3+json\"" \
            "https://api.github.com/repos/${{ github.repository }}/issues" \
            "-d '$payload'")
          echo "##[debug][notify] ISSUE COMMAND: $CURL_CMD"
          eval "$CURL_CMD"
        }

        echo "##[debug][notify] Creating issue in the repository with the constructed title and body."
        create_issue "$ISSUE_TITLE" "$ISSUE_BODY"

        if [ $? -ne 0 ]; then
          echo "##[error][notify] Failed to notify teams and committer."
          exit 46
        fi

    # Step 10: Catch-all for failures.
    - name: Catch-all for unspecified errors
      if: ${{ always() }}
      run: |
 
        echo "##[debug][catch-all] Check if an issue with title "Commit Guard Workflow Error: ${{ github.run_id }}" already exists."

        BASE_URL="https://api.github.com/search/issues"
        REPO_PARAM="repo:${{ github.repository }}"
        TYPE_PARAM="type:issue"
        STATE_PARAM="state:open"
        TITLE_PARAM="in:title"
        ERROR_PARAM="Commit+Guard+Workflow+Error:${{ github.run_id }}"
        FULL_URL=$(echo "${BASE_URL}?q=${REPO_PARAM}+${TYPE_PARAM}+${STATE_PARAM}+${TITLE_PARAM}+${ERROR_PARAM}")
        
        issue_exists=$(curl \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "$FULL_URL" \
          | jq '.total_count')

        if [[ $issue_exists -eq 0 ]]; then
          echo "##[debug][catch-all] Constructing notification title and body  to the previous step."
          ISSUE_TITLE="Commit Guard Workflow Error: ${{ github.run_id }}"
          ISSUE_BODY=$(echo "Hello @${{ github.repository_owner }}

          An unexpected error occurred during the execution of the ${{ github.workflow }} workflow.#
          Check the logs for more details. 

          Workflow ID: ${{ github.run_id }}")

          create_issue() {
            local title="$1"
            local body="$2"
            payload=$(jq -n \
              --arg title "$title" \
              --arg body "$body" \
              '{title: $title, body: $body}')
            CURL_CMD=$(echo "curl -X POST" \
              "-H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\"" \
              "-H \"Accept: application/vnd.github.v3+json\"" \
              "https://api.github.com/repos/${{ github.repository }}/issues" \
              "-d '$payload'")
            echo "##[debug][catch-all] ISSUE COMMAND: $CURL_CMD"
            eval "$CURL_CMD"
          }

          echo "##[debug][catch-all] Creating issue in the repository with the constructed title and body."
          create_issue "$ISSUE_TITLE" "$ISSUE_BODY"
        fi
        
        echo "##[error][catch-all] An error has occurred executing ${{ github.workflow }} run ${{ github.run_id }}"
        exit 33
