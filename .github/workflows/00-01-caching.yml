---
######################################
# Workflow: Cache Dependencies

# Description:
# This workflow caches the .NET dependencies for the payload .csproj. By caching 
# dependencies, subsequent workflow runs can be expedited by reusing previously 
# cached dependencies, provided the .csproj file remains unchanged.

# Trigger: Activated upon receiving the event `Cache Dependencies`.

# Logical Flow (Steps):
# 1.  The workflow starts by verifying that it's being executed within a git repository.
# 2.  It then checks out the specific SHA from the repository.
# 3.  A verification step ensures the checkout was successful.
# 4.  The .NET dependencies for the provided .csproj file are restored.
# 5.  The restored .NET dependencies are cached for future use.
# 6.  Upon successful caching, the workflow triggers the next workflow in the pipeline.
# 7.  A catch-all step handles unspecified errors.

# Exit Codes:
# 20 - Not executing within a git directory. (Reused)
# 26 - SHA checkout failure. (Reused)

# 90 - 
# 91 - Failed to trigger the next workflow. (Reused)
# 99 - Catch-all for unhandled errors. (Reused)

######################################

name: Cache Dependencies

on:
  repository_dispatch:
    types: Cache Dependencies

env:
  SHA: ${{ github.event.client_payload.sha }}
  SHA_BRANCH: ${{ github.event.client_payload.sha_branch }}
  CSPROJ: ${{ github.event.client_payload.csproj }}
  NEXT_WORKFLOW: StyleCop Linter

jobs:
  cache-dependencies:
    name: Cache Dependencies
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:

    # Step 1: Verify the workflow is running inside a git repository.
    - name: Verify Workflow Run is Git Repository
      run: |
 
        if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
          echo "##[debug][repo-run] Execution confirmed inside git repository."
        else
          echo "##[error][repo-run] Not executing within a git directory."
          exit 20
        fi

    # Step 2: Checkout repository using SHA.
    - name: Checkout SHA Repository
      id: checkout-sha
      uses: actions/checkout@v3.6.0
      with:
        ref: ${{ github.sha }}
        fetch-depth: 0

    # Step 3: Validate SHA checkout.
    - name: Validate Checkout
      run: |
 
        if [ $? -ne 0 ]; then
            echo "##[error][checkout] SHA checkout failure ${{ github.sha }}"
            exit 26
        fi

    # Step 4: Restore dotnet project to acquire eg: nuget packages
    - name: Restore dotnet Dependencies
      run: |
 
        echo "##[info][dotnet] Restoring .NET dependencies for ${{ env.CSPROJ }}"
        dotnet restore --no-cache "${{ env.CSPROJ }}" -v detailed
        if [ $? -ne 0 ]; then
          echo "##[error][dotnet] Dotnet restore failed for ${{ env.CSPROJ }}"
          exit 50
        fi
        echo "##[debug][dotnet] Restored .NET dependencies for ${{ env.CSPROJ }}"

    # Step 5: Cache acquired packages 
    - name: Cache dotnet Dependencies
      uses: actions/cache@v3.3.1
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-dotnet-${{ hashFiles('${{ env.SHA }}') }}
        restore-keys: |
          ${{ runner.os }}-dotnet-

    # Step 6: Trigger next workflow if all checks pass.
    - name: Trigger Next Workflow and Dispatch Success Event
      if: success()
      run: |
 
        echo "##[info][trigger] Sending success event for Authentication Gate workflow."

        SUCCESS_CMD=$(echo "curl -L -X POST" \
         "-H \"Accept: application/vnd.github+json\"" \
         "-H \"Authorization: Bearer ${{ secrets.AUTH }}\"" \
         "https://api.github.com/repos/${{ github.repository }}/dispatches" \
         "-d '{\"event_type\":\"Authentication Gate Success\"," \
         "\"client_payload\":{" \
         "\"message\":\"Workflow completed successfully\"}}'")

        eval "$SUCCESS_CMD"
        if [[ $? -ne 0 ]]; then
          echo "##[error][trigger] Failed to send success event."
        else
          echo "##[info][trigger] Success event dispatched."
        fi

        echo "##[info][trigger] Initiating the next workflow: ${{ env.NEXT_WORKFLOW }}."

        CMD=$(echo "curl -L -X POST" \
         "-H \"Accept: application/vnd.github+json\"" \
         "-H \"Authorization: Bearer ${{ secrets.AUTH }}\"" \
         "https://api.github.com/repos/${{ github.repository }}/dispatches" \
         "-d '{\"event_type\":\"${{ env.NEXT_WORKFLOW }}\"," \
         "\"client_payload\":{" \
         "\"sha\":\"${{ env.SHA }}\"," \
         "\"sha_branch\":\"${{ env.SHA_BRANCH }}\"," \
         "\"csproj\":\"${{ env.CSPROJ }}\"}'")

        retries=0
        while [[ $retries -lt ${{ vars.MAX_RETRIES }} ]]; do
          eval "$CMD"
          CURL_EXIT_CODE=$?
          if [[ $CURL_EXIT_CODE -ne 0 ]]; then
            echo "##[error][trigger] Attempt $((retries+1)) failed with exit code $CURL_EXIT_CODE."
            retries=$((retries+1))
            if [[ $retries -lt ${{ vars.MAX_RETRIES }} ]]; then
              echo "##[warn][trigger] Retrying in ${{ vars.WAIT_SECONDS }} seconds..."
              sleep ${{ vars.WAIT_SECONDS }}
            else
              echo "##[error][trigger] All retries exhausted. Failed to trigger ${{ env.NEXT_WORKFLOW }}."
              exit 32
            fi
          else
            echo "##[info][trigger] ${{ env.NEXT_WORKFLOW }} successfully triggered."
            break
          fi
        done

    # Step 7: Catch-all for unspecified errors.
    - name: Catch-All Error Handler
      if: failure()
      run: |
 
        echo "##[error][unhandled] An unidentified error has occurred."
        exit 99
