---
name: Authentication Gate

on:
  push:
    branches: ["code-development", "code-production", "code-staging", "main"]

env:
  NEXT_WORKFLOW: Cache Dependencies

jobs:

  authentication-gate:
    name: Authentication Gate
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: (github.actor != ${{ github.repository_owner }}) # ignore DevOps
    
    steps:

    - name: Sanitise and Validate Untrusted User-Controlled Details
      run: |
      
        echo "##[info] Starting security sanitisation and validation."

        echo "##[debug] Git username can start and or end with an alphanumeric character."
        echo "##[debug] Can have hyphens but not at the start or end."
        echo "##[debug] Has a maximum length of 20 characters (including hyphens)."
        regex_pattern="^([a-z0-9](-?[a-z0-9]){0,19})$"

        username=$(echo ${{ github.event.head_commit.author.name }} | tr '[:upper:]' '[:lower:]')
        if ! [[ "$username" =~ ${regex_pattern} ]] || [[ "$username" == -* ]]; then
            echo "##[error] Username contains invalid characters" && exit 20
        fi

        echo "##[debug] Git email address can start with a sequence of letters, numbers and special characters like . _ % + and -"
        echo "##[debug] followed by the @ symbol, then followed by a domain name consisting of letters, numbers, dots and hyphens"
        echo "##[debug] and ending with a top-level domain of 2 to 4 letters."
        echo "##[debug] The inclusion of + in the local part allows it match GitHub's autogenerated email addresses."
        regex_pattern="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$"
        
        if ! [[ "${{ github.event.head_commit.author.email }}" =~ ${regex_pattern} ]]; then
            echo "##[error] Email format is invalid" && exit 21
        fi

        echo "##[debug] Commit messages cannot contain some dangerous chars, to inhibit injection of shell commands."
        forbidden_chars="|*[]<(){]}>S"
        commit_msg="${{ github.event.head_commit.message }}"
        for (( i=0; i<${#forbidden_chars}; i++ )); do
            char="${forbidden_chars:$i:1}"  # Extract each character one by one
            echo "##[debug] "
            if [[ $commit_msg == *"$char"* ]]; then
                echo "##[error] Commit message ${commit_msg} contains invalid character $char." && exit 22
            fi
        done

        echo "##[info] Sanitisation and validation completed successfully."

    - name: Checkout SHA Repository
      id: checkout-sha
      uses: actions/checkout@v3.6.0
      with:
        ref: ${{ github.sha }}
        fetch-depth: 0

    - name: Validate SHA Checkout
      run: |
      
        echo "##[info] Validating checkout for SHA ${{ github.sha }}"
        if [[ "${{ steps.checkout-sha.outcome }}" == "failure" ]]; then
            echo "##[error] SHA checkout FAIL for ${{ github.sha }}" && exit 23
        fi
        echo "##[info] Successfully validated SHA checkout for ${{ github.sha }}"
        echo "SHA=${{ github.sha }}" >> $GITHUB_ENV

    - name: Configure Git User
      run: |
      
        echo "##[info] Configuring git user account for ${{ env.SHA }}"
        git config user.name "${{ github.repository_owner}}"
        git config user.email "${{ vars.EMAIL }}"

    - name: Validate Commit as Unique to Existent Remote SHA Branch
      run: |
      
        echo "##[info] Validating SHA branch for ${{ env.SHA }}"
        branch_list=$(git branch -r --contains ${{ env.SHA }} | sed 's/origin\///' | xargs)
        if [[ -z "$branch_list" ]]; then
          echo "##[error] No branches found containing the commit in ${{ github.repository }}" && exit 24
        fi

        echo "##[debug] Checking if multiple branches contain the commit SHA ${{ env.SHA }}"
        branch_count=$(echo $branch_list | wc -w)
        if [[ $branch_count -gt 1 ]]; then
          echo "##[error] Multiple branches contain commit SHA ${{ env.SHA }} in ${{ github.repository }}: $branch_list" && exit 25
        fi
        branch=$(echo $branch_list | awk '{print $1}')

        echo "##[info] Successfully validated SHA branch name $branch for commit SHA ${{ env.SHA }}."
        echo "SHA_BRANCH=$branch" >> $GITHUB_ENV

    - name: Check for Pre-Existent .lock File in History
      run: |
  
        echo "##[info] Checking for pre-existent lock file in the commit immediately before SHA ${{ env.SHA }}."

        echo "##[debug] Fetching branch ${{ env.SHA_BRANCH }}"
        if ! git fetch origin ${{ env.SHA_BRANCH }}; then
            echo "##[error] Failed to fetch ${{ env.SHA_BRANCH }}" && exit 26
        fi
        
        echo "##[debug] Define the lock file based on the branch ${{ env.SHA_BRANCH }}"
        branch=${{ env.SHA_BRANCH }}
        if [[ $branch == "code-"* ]]; then
            LOCK_FILE=.${branch#code-}.lock
        elif [[ $branch == "main" ]]; then
            LOCK_FILE=.main.lock
        fi
        
        echo "##[debug] Check the lock file's presence in the commit immediately before SHA ${{ env.SHA }}"
        if git show ${{ env.SHA }}^:$LOCK_FILE &> /dev/null; then
            echo "##[error] Lock file $LOCK_FILE was found in the commit immediately before SHA ${{ env.SHA }}." && exit 27
        else
            echo "##[info] Lock file $LOCK_FILE does not exist in the commit immediately before SHA ${{ env.SHA }} - proceeding."
        fi
        
        echo "##[debug] Adding and committing the new lock file $LOCK_FILE for SHA ${{ env.SHA }}"
        echo "${{ env.SHA }}" > "$LOCK_FILE"
        git add "$LOCK_FILE"
        git commit -m "Adding $LOCK_FILE for ${{ env.SHA }} [skip ci]."
        
        echo "##[debug] Pushing the lock file $LOCK_FILE."
        if ! git push origin HEAD:${{ env.SHA_BRANCH }}; then
            echo "##[error] Failed to push $LOCK_FILE for ${{ env.SHA }}" && exit 28
        fi
        
        echo "##[debug] Fetching again to ensure $LOCK_FILE commit went through."
        git fetch origin ${{ env.SHA_BRANCH }}
        if [ $? -ne 0 ]; then
            echo "##[error] Failed to fetch ${{ env.SHA_BRANCH }}" && exit 29
        fi
        
        echo "##[debug] Checking that lock file @$LOCK_FILE is present in the remote."
        if ! git ls-tree HEAD -- $LOCK_FILE; then
            echo "##[error] Expected lock file $LOCK_FILE was not detected remotely" && exit 30
        fi
        
        echo "##[info] Lock file $LOCK_FILE created and pushed to ${{ env.SHA_BRANCH }} for commit SHA ${{ env.SHA }}"


    - name: Trigger Next Workflow
      if: success()
      run: |
      
        CMD=(
          curl -L -X POST
          -H "Accept: application/vnd.github+json"
          -H "Authorization: Bearer ${{ secrets.AUTH }}"
          -H "X-GitHub-Api-Version: 2022-11-28"
          "https://api.github.com/repos/${{ github.repository }}/dispatches"
          -d "{
            \"event_type\":\"$trigger\",
            \"client_payload\": {
              \"sha\":\"${{ env.SHA }}\",
              \"sha_branch\":\"${{ env.SHA_BRANCH }}\"
            }}")

        retries=0
        while [[ $retries -lt ${{ vars.MAX_RETRIES }} ]]; do
          eval "$CMD"
          CURL_EXIT_CODE=$?
          if [[ $CURL_EXIT_CODE -ne 0 ]]; then
            echo "##[error] Curl command failed on attempt $((retries+1)) with exit code $CURL_EXIT_CODE"
            retries=$((retries+1))
            if [[ $retries -lt ${{ vars.MAX_RETRIES }} ]]; then
              echo "##[warn] Retrying in ${{ vars.WAIT_SECONDS }} seconds..."
              sleep ${{ vars.WAIT_SECONDS }}
            else
              echo "##[error] Exhausted ${{ vars.MAX_RETRIES }} retries at ${{ vars.WAIT_SECONDS }} intervals."
              echo "##[error] Failed to trigger ${{ env.NEXT_WORKFLOW }} workflow with CURL command: $CMD." && exit 90
            fi
          else
            break # successful curl
          fi    
        done
        echo "##[debug] CURL command: $CMD"
