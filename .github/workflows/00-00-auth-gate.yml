---
######################################
# Workflow: Authentication Gate

# Description:
# This workflow manages the authentication and validation of commits before triggering subsequent workflows.
# It checks if the push is within a git repository, sanitises and validates untrusted user details, validates branch names,
# checks .csproj files, and ensures that commits are unique to existing remote SHA branches.

# Trigger: Activated upon every push made to any branch.

# Logical Flow (Steps):
# 1.  Sanitise and validate untrusted user-controlled details.
# 2.  Validate branch names.
# 3.  Revert commits if the branch name is unknown.
# 4.  Checkout repository using the commit SHA.
# 5.  Validate the SHA checkout.
# 6.  Ensure commit is unique to existing remote SHA branches.
# 7.  Validate the existence of a .csproj file.
# 8.  Check for pre-existent .lock files in the commit.
# 9.  Trigger next workflow if all checks pass.
# 10. Handle unspecified errors with a catch-all error handler.

# Exit Codes:
# 21 - Username contains invalid characters.
# 22 - Email format is invalid.
# 23 - Commit message contains invalid characters.
# 24 - Failed to reset repository.
# 25 - Failed to push reversion.
# 26 - SHA checkout failure.
# 27 - No branches found containing the commit.
# 28 - Multiple branches contain the commit SHA.
# 29 - Failed to find the .csproj file.
# 30 - Failed to fetch the branch.
# 31 - Lock file issue.
# 32 - Failed to trigger the next workflow.

######################################

name: Authentication Gate

on:
  push:

env:
  NEXT_WORKFLOW: Cache Dependencies

jobs:
  authentication-gate:
    name: Authentication Gate
    runs-on: ubuntu-latest
    timeout-minutes: 15

    if: (github.actor != ${{ github.repository_owner }}) # Ignore DevOps

    steps:

    # Step 1: Sanitisation and validation of untrusted user-controlled details.
    - name: Sanitise and Validate User Details
      run: |
 
        echo "##[info][sanitise] Starting security sanitisation and validation."

        echo "##[debug][sanitise] Sanitising username as github username."
        regex_pattern="^([a-z0-9](-?[a-z0-9]){0,19})$"
        username=$(echo ${{ github.event.head_commit.author.name }} | tr '[:upper:]' '[:lower:]')
        if ! [[ "$username" =~ ${regex_pattern} ]] || [[ "$username" == -* ]]; then
            echo "##[error][sanitise] Username contains invalid characters"
            exit 21
        fi

        echo "##[debug][sanitise] Sanitising email address."
        regex_pattern="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$"
        if ! [[ "${{ github.event.head_commit.author.email }}" =~ ${regex_pattern} ]]; then
            echo "##[error][sanitise] Email format is invalid"
            exit 22
        fi

        echo "##[debug][sanitise] Sanitising commit message."
        forbidden_chars="|*]>)}<{([S"
        echo "##[debug][sanitise] Forbidden characters: $forbidden_chars"
        commit_msg="${{ github.event.head_commit.message }}"
        for (( i=0; i<${#forbidden_chars}; i++ )); do
            char="${forbidden_chars:$i:1}"
            echo "##[debug][sanitise] Checking for forbidden char $char"
            if [[ $commit_msg == *"$char"* ]]; then
                echo "##[error][sanitise] Commit message ${commit_msg} contains invalid character $char."
                exit 23
            fi
        done

        echo "##[info][sanitise] Sanitisation and validation completed successfully."

    # Step 2: Branch name validation.
    - name: Validate Branch Name
      run: |
 
        ALLOWED_BRANCHES=("code-development" "code-staging" "code-production" "main")
        REF=${{ github.ref }}
        BRANCH_NAME=${REF#refs/heads/}
        echo "##[debug][branch] Branch: $BRANCH_NAME"

        echo "##[debug][branch] Looping through allowed branches to check if the current branch is valid."
        echo "isValidBranch=false" >> $GITHUB_ENV
        for branch in "${ALLOWED_BRANCHES[@]}"
        do
            if [[ "$BRANCH_NAME" == "$branch" ]]; then
                echo "##[info][branch] Branch $BRANCH_NAME is valid."
                echo "isValidBranch=true" >> $GITHUB_ENV
                break
            fi
        done

    # Step 3: Commit reversion if the branch name is unknown.
    - name: Revert Unknown Branch Commits
      if: env.isValidBranch == 'false'
      run: |
 
        COMMIT_COUNT=$(git rev-list --count HEAD)
        if [[ $COMMIT_COUNT -le 1 ]]; then
            echo "##[error][revert] Only one commit in this branch. Nowhere to revert to."
            exit 0
        fi

        ORIGINAL_COMMITTER=$(git log --pretty=format:'%an' ${{ github.sha }} | head -n 1)
        if [[ "$ORIGINAL_COMMITTER" == "${{ github.repository_owner }}" ]]; then
            echo "##[warn][revert] Last commit was by repository owner (possibly an automated revert) - skipping further actions."
            exit 0
        fi

        git reset HEAD --hard
        if [[ $? -ne 0 ]]; then
            echo "##[error][revert] Failed to reset repository."
            exit 24
        fi

        git config user.name "${{ github.repository_owner }}"
        git config user.email "${{ vars.EMAIL }}"

        if git push origin +$BRANCH_NAME; then
          echo "##[debug][revert] Pushed reversion."
        else
          echo "##[error][revert] Failed to push reversion."
          exit 25
        fi

        MESSAGE_TITLE="Reverted ${{ github.sha }} --> Unknown Branch"
        MESSAGE_BODY=$(echo "@${{ github.repository_owner }},
          Branch: $BRANCH_NAME
          SHA: ${{ github.sha }} 
          Committer: $ORIGINAL_COMMITTER
          Commit Message: $COMMIT_MESSAGE
          ${{ github.sha }} committed to an unknown branch, was reverted.
          Thank you for your contribution.")
        echo "##[debug][revert] MESSAGE_TITLE: $MESSAGE_TITLE"
        echo "##[debuf][revert] MESSAGE_BODY: $MESSAGE_BODY"

        create_issue "$MESSAGE_TITLE" "$MESSAGE_BODY"
        echo "##[warn][revert] Last commit was reverted."
        exit 0

    # Step 4: Checkout repository using SHA.
    - name: Checkout SHA Repository
      id: checkout-sha
      uses: actions/checkout@v3.6.0
      with:
        ref: ${{ github.sha }}
        fetch-depth: 0

    # Step 5: Validate SHA checkout.
    - name: Validate Checkout
      run: |
 
        if [ $? -ne 0 ]; then
            echo "##[error][checkout] SHA checkout failure ${{ github.sha }}"
            exit 26
        fi

    # Step 6: Ensure commit is unique to existing remote SHA branches.
    - name: Check Commit Uniqueness
      run: |
 
        BRANCHES_CONTAINING_COMMIT=$(git branch -r --contains ${{ github.sha }})
        echo "##[debug][unique] BRANCHES_CONTAINING_COMMIT: $BRANCHES_CONTAINING_COMMIT"

        BRANCH_COUNT=$(echo "$BRANCHES_CONTAINING_COMMIT" | wc -l)
        echo "##[debug][unique] BRANCH_COUNT: $BRANCH_COUNT"

        if [[ $BRANCH_COUNT -eq 0 ]]; then
            echo "##[warn][unique] No branches found containing the commit ${{ github.sha }}."
            exit 27
        elif [[ $BRANCH_COUNT -gt 1 ]]; then
            echo "##[error][unique] Multiple branches contain the commit SHA ${{ github.sha }}."
            exit 28
        fi

    # Step 7: Validation of the .csproj file.
    - name: Validate .csproj File
      run: |
 
        CSPROJ_PATH=$(find . -name "*.csproj" | head -n 1)
        echo "##[debug][csproj] CSPROJ_PATH: $CSPROJ_PATH"
        
        if [[ -z "$CSPROJ_PATH" ]]; then
            echo "##[error][csproj] Failed to find the .csproj file $CSPROJ_PATH."
            exit 29
        fi

    # Step 8: Check for pre-existent .lock files in history.
    - name: Check for Pre-Existent .lock Files
      run: |
 
        git fetch origin
        if [[ $? -ne 0 ]]; then
            echo "##[error][lockfile] Failed to fetch the branch."
            exit 30
        fi
        LOCK_FILE_PATH=$(find . -name "*.lock" | head -n 1)
        if [[ -n "$LOCK_FILE_PATH" ]]; then
            echo "##[error][lockfile] Lock file $LOCK_FILE_PATH issue."
            exit 31
        fi

    # Step 9: Trigger next workflow if all checks pass.
    - name: Trigger Next Workflow and Dispatch Success Event
      if: success()
      run: |
 
        echo "##[info][trigger] Initiating the next workflow: ${{ env.NEXT_WORKFLOW }}."
        SUCCESS_CMD=$(echo "curl -L -X POST" \
         "-H \"Accept: application/vnd.github+json\"" \
         "-H \"Authorization: Bearer ${{ secrets.AUTH }}\"" \
         "https://api.github.com/repos/${{ github.repository }}/dispatches" \
         "-d '{\"event_type\":\"Authentication Gate Success\"," \
         "\"client_payload\":{" \
         "\"message\":\"Workflow completed successfully\"}}'")

        eval "$SUCCESS_CMD"
        if [[ $? -ne 0 ]]; then
          echo "##[error][trigger] Failed to send success event."
        else
          echo "##[info][trigger] Success event dispatched."
        fi

        CMD=$(echo "curl -L -X POST" \
         "-H \"Accept: application/vnd.github+json\"" \
         "-H \"Authorization: Bearer ${{ secrets.AUTH }}\"" \
         "https://api.github.com/repos/${{ github.repository }}/dispatches" \
         "-d '{\"event_type\":\"${{ env.NEXT_WORKFLOW }}\"," \
         "\"client_payload\":{" \
         "\"sha\":\"${{ env.SHA }}\"," \
         "\"sha_branch\":\"${{ env.SHA_BRANCH }}\"," \
         "\"csproj\":\"${{ env.CSPROJ }}\"}'")

        retries=0
        while [[ $retries -lt ${{ vars.MAX_RETRIES }} ]]; do
          eval "$CMD"
          CURL_EXIT_CODE=$?
          if [[ $CURL_EXIT_CODE -ne 0 ]]; then
            echo "##[error][trigger] Attempt $((retries+1)) failed with exit code $CURL_EXIT_CODE."
            retries=$((retries+1))
            if [[ $retries -lt ${{ vars.MAX_RETRIES }} ]]; then
              echo "##[warn][trigger] Retrying in ${{ vars.WAIT_SECONDS }} seconds..."
              sleep ${{ vars.WAIT_SECONDS }}
            else
              echo "##[error][trigger] All retries exhausted. Failed to trigger ${{ env.NEXT_WORKFLOW }}."
              exit 32
            fi
          else
            echo "##[info][trigger] ${{ env.NEXT_WORKFLOW }} successfully triggered."
            break
          fi
        done
